1.离散化
2.尺取法
3.java
4.vim配置


1. 离散化:就是将n个数字和1~n对应起来
使用STL算法离散化：
思路：先排序，再删除重复元素，然后就是索引元素离散化后对应的值。

/*
 * eg:
 * 一组数据:1,4,1000,100000;直接开线段树很浪费,则先离散化
 *
 * 离散化前 a[i]: 1,    4,   1000, 100000,
 * 离散化后 a[i]: 1,    2,    3,    4,
 *               a[0], a[1], a[2], a[3],
 */

const int maxn = 100;
int n=6;
int a[maxn];//离散化后的数组a
void lisan(int *arr)//传入数组arr[0..n-1],返回a[0..n-1]
{
    for (int i=0;i<n;i++) a[i]=arr[i];

    sort(a,a+n);
    int size = unique(a,a+n)-a; //size是离散化后元素个数
    for (int i=0;i<n;i++)
        a[i] = lower_bound(a,a+size,arr[i])-a+1;
}

int main()
{
    int qq[20]={0,1,4,6,7,800,1000};
    lisan(qq);
    for (int i=0;i<=n;i++)
        cout << "i:" << i << "   a:[" << i << "]: "<<  a[i] << endl;

    return 0;
}



--------------------------------------------------------------------
2. 尺取法
像尺子一样取一段,设置左右端点,不断右移右端点和左端点,直到找到最优解  

挑战程序竞赛 P146  
挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。  

作用:尺取法是一种高效的枚举区间的方法(数据量大时比暴力枚举高效很多)  

应用：(优化枚举区间效率)  
1. 求有一定限制的区间个数或最短的区间等等  
2. 最短的覆盖所有点的子序列 poj3320  

模板如下:四步
int chiqu()
{
    int ans = INF;
    int s=0,t=0,sum=0;//左右端点和前缀和
    while(1)
    {
        while(t<n && sum<S)
            sum += a[t++];//右端点右移
        if (sum<S) break;
        ans = min(ans,t-s);
        sum -= a[s++];//左端点右移
    }
    if (ans == INF) ans=0;
    return ans;
}


